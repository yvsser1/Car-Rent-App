'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _class, _temp2;

// For some weird reason, in Chrome, `setTimeout()` would lag up to a second (or more) behind.
// Turns out, Chrome developers have deprecated `setTimeout()` API entirely without asking anyone.
// Replacing `setTimeout()` with `requestAnimationFrame()` can work around that Chrome bug.
// https://github.com/bvaughn/react-virtualized/issues/722


var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

var _requestAnimationFrameTimeout = require('request-animation-frame-timeout');

var _dom = require('./utility/dom');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// `PureComponent` is only available in React >= 15.3.0.
var PureComponent = _react2.default.PureComponent || _react2.default.Component;

// https://github.com/Dogfalo/materialize/blob/master/js/tooltip.js
var Tooltip = (_temp2 = _class = function (_PureComponent) {
	_inherits(Tooltip, _PureComponent);

	function Tooltip() {
		var _ref;

		var _temp, _this, _ret;

		_classCallCheck(this, Tooltip);

		for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
			args[_key] = arguments[_key];
		}

		return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Tooltip.__proto__ || Object.getPrototypeOf(Tooltip)).call.apply(_ref, [this].concat(args))), _this), _this.state = {}, _this.show = function () {
			_this.isShown = true;

			// Play tooltip showing animation
			var animate = false;

			// If hiding animation is being played,
			// then cancel it, and cancel setting
			// `display` to `none` after it finishes playing.
			if (_this.hide_timeout) {
				(0, _requestAnimationFrameTimeout.clearTimeout)(_this.hide_timeout);
				_this.hide_timeout = undefined;

				// Abort tooltip hiding animation.
				// It will automatically return to the "showing" state.
				_this.tooltip.classList.remove('rrui__tooltip--before-hide');
			}
			// Otherwise, the tooltip is hidden (or never been shown)
			else {
					// Not creating in `componentDidMount()`
					// therefore create it here.
					if (!_this.tooltip) {
						_this.createTooltip();
					}

					// Play tooltip showing animation
					animate = true;
				}

			// Now that `this.tooltip` has been created,
			// re-render the component so that `ReactDOM.createPortal()` is called.
			return new Promise(function (resolve) {
				_this.setState({ isShown: true }, function () {
					var accessible = _this.props.accessible;

					var _this$calculate_coord = _this.calculate_coordinates(),
					    x = _this$calculate_coord.x,
					    y = _this$calculate_coord.y;

					_this.tooltip.style.left = x + 'px';
					_this.tooltip.style.top = y + 'px';

					// Play tooltip showing animation
					// (doing it after setting position because
					//  setting position applies `display: block`)
					// (whatever that meant, the animation won't work
					//  if this is done before setting `left` and `top`)
					if (animate) {
						_this.tooltip.classList.add('rrui__tooltip--after-show');
					}

					if (_this.isTouchDevice) {
						document.addEventListener('touchstart', _this.hideOnTouchOutside);
					}

					resolve();
				});
			});
		}, _this.hide = function () {
			_this.isShown = false;

			var hidingAnimationDuration = _this.props.hidingAnimationDuration;

			// If already hiding, or if already hidden, then do nothing.
			// if (this.hide_timeout || this.tooltip.style.display === 'none')

			if (_this.hide_timeout || !_this.tooltip) {
				return;
			}

			if (_this.isTouchDevice) {
				document.removeEventListener('touchstart', _this.hideOnTouchOutside);
			}

			// Play tooltip hiding animation
			_this.tooltip.classList.add('rrui__tooltip--before-hide');

			return new Promise(function (resolve) {
				// Set the tooltip to `display: none`
				// after its hiding animation finishes.
				_this.hide_timeout = (0, _requestAnimationFrameTimeout.setTimeout)(function () {
					_this.hide_timeout = undefined;
					_this.destroy_tooltip();
					if (_this._isMounted) {
						_this.setState({ isShown: false }, resolve);
					}
				}, hidingAnimationDuration);
			});
		}, _this.hideOnTouchOutside = function (event) {
			if (_this.isShown) {
				if (!_this.tooltip.contains(event.target) && !_this.origin.contains(event.target)) {
					_this.hide();
				}
			}
		}, _this.onClick = function () {
			if (_this.isShown) {
				_this.hide();
			} else {
				_this.show().then(function () {
					// An "accessible" tooltip is focused upon being shown.
					_this.tooltip.focus();
				});
			}
		}, _this.onMouseMove = function () {
			document.removeEventListener('mousemove', _this.onMouseMove);
			_this.onMouseEnter();
		}, _this.onMouseEnterTooltip = function () {
			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (_this.isTouchDevice) {
				return;
			}

			_this.isPointerInsideTooltip = true;

			if (_this.isShown) {
				_this.cancelHide();
			}
		}, _this.onMouseLeaveTooltip = function () {
			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (_this.isTouchDevice) {
				return;
			}

			_this.isPointerInsideTooltip = false;

			if (_this.isPointerInsideElement) {
				return;
			}

			if (_this.isShown) {
				_this.scheduleHide();
			}
		}, _this.onMouseEnter = function () {
			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (_this.isTouchDevice) {
				return;
			}

			if (DocumentMouseMove.wasMouseMoved) {
				_this._onMouseEnter();
			} else {
				// This code handles the case when a user has scrolled
				// and the mouse pointer got placed over the minimized quote
				// but that didn't trigger the "expand" action (intentionally)
				// and then the user moves the mouse and that should expand
				// the minimized quote.
				document.addEventListener('mousemove', _this.onMouseMove);
			}
		}, _this.onMouseLeave = function () {
			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (_this.isTouchDevice) {
				return;
			}

			// The `mousemove` listener might have, or might have not,
			// been added, so remove it (if it has been added).
			document.removeEventListener('mousemove', _this.onMouseMove);

			_this.isPointerInsideElement = false;

			if (_this.isPointerInsideTooltip) {
				return;
			}

			// If tooltip hasn't been shown yet,
			// then cancel showing it.
			if (_this.show_timeout) {
				(0, _requestAnimationFrameTimeout.clearTimeout)(_this.show_timeout);
				_this.show_timeout = undefined;
				return;
			}

			// Otherwise, the tooltip is shown, so hide it.
			if (_this.isShown) {
				_this.scheduleHide();
			}
		}, _this.onTouchStartSetTouchDevice = function () {
			return _this.isTouchDevice = true;
		}, _this.onTouchStart = function () {
			var content = _this.renderContent();

			// mouse enter events won't be processed from now on
			_this.isTouchDevice = true;

			// If the tooltip has no content
			// (e.g. `react-time-ago` first render)
			// or if React Portal API is not available
			// then don't show the tooltip.
			if (!content || !_reactDom2.default.createPortal) {
				return;
			}

			if (_this.isShown) {
				_this.hide();
			} else {
				_this.show();
			}
		}, _this.onTouchEnd = function () {}, _this.onFocusOut = function (event) {
			if (!_this.tooltip.contains(event.relatedTarget) && !_this.origin.contains(event.relatedTarget)) {
				_this.hide();
			}
		}, _this.onKeyDown = function (event) {
			if (event.defaultPrevented) {
				return;
			}
			if (event.ctrlKey || event.altKey || event.shiftKey || event.metaKey) {
				return;
			}
			switch (event.keyCode) {
				// Hide on "Escape".
				case 27:
					event.preventDefault();
					// Hide (if not already hidden).
					_this.hide();
					var accessible = _this.props.accessible;

					if (accessible) {
						_this.origin.focus();
					}
					return;
			}
		}, _this.storeOriginNode = function (ref) {
			return _this.origin = ref;
		}, _temp), _possibleConstructorReturn(_this, _ret);
	}

	_createClass(Tooltip, [{
		key: 'componentDidMount',
		value: function componentDidMount() {
			this._isMounted = true;
		}
	}, {
		key: 'componentWillUnmount',
		value: function componentWillUnmount() {
			this._isMounted = false;
			this.destroy_tooltip();
			(0, _requestAnimationFrameTimeout.clearTimeout)(this.show_timeout);
			// The `mousemove` listener might have, or might have not,
			// been added, so remove it (if it has been added).
			document.removeEventListener('mousemove', this.onMouseMove);
		}
	}, {
		key: 'createTooltip',
		value: function createTooltip() {
			var _props = this.props,
			    tooltipClassName = _props.tooltipClassName,
			    placement = _props.placement,
			    accessible = _props.accessible;


			this.tooltip = document.createElement('div');

			this.tooltip.style.position = 'absolute';
			this.tooltip.style.left = 0;
			this.tooltip.style.top = 0;

			if (accessible) {
				// An "accessible" tooltip is focused upon being shown.
				this.tooltip.setAttribute('tabIndex', -1);
				this.tooltip.classList.add('rrui__outline');
				this.tooltip.addEventListener('focusout', this.onFocusOut);
			}

			this.tooltip.classList.add('rrui__tooltip');
			this.tooltip.classList.add('rrui__tooltip--' + getEdge(placement));

			if (tooltipClassName) {
				for (var _iterator = tooltipClassName.split(/\s+/), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
					var _ref2;

					if (_isArray) {
						if (_i >= _iterator.length) break;
						_ref2 = _iterator[_i++];
					} else {
						_i = _iterator.next();
						if (_i.done) break;
						_ref2 = _i.value;
					}

					var className = _ref2;

					this.tooltip.classList.add(className);
				}
			}

			this.tooltip.addEventListener('mouseenter', this.onMouseEnterTooltip);
			this.tooltip.addEventListener('mouseleave', this.onMouseLeaveTooltip);
			this.tooltip.addEventListener('keydown', this.onKeyDown);

			this.container().appendChild(this.tooltip);
		}
	}, {
		key: 'destroy_tooltip',
		value: function destroy_tooltip() {
			(0, _requestAnimationFrameTimeout.clearTimeout)(this.hide_timeout);
			(0, _requestAnimationFrameTimeout.clearTimeout)(this.hide_on_mouse_leave_timeout);

			if (this.tooltip) {
				// Won't throw an exception
				this.tooltip.parentNode.removeChild(this.tooltip);
				this.tooltip = undefined;
			}
		}
	}, {
		key: 'container',
		value: function container() {
			var container = this.props.container;

			return container();
		}
	}, {
		key: 'calculate_coordinates',
		value: function calculate_coordinates() {
			var _props2 = this.props,
			    placement = _props2.placement,
			    screenMargin = _props2.screenMargin,
			    offsetTop = _props2.offsetTop;


			var width = this.tooltip.offsetWidth;
			var height = this.tooltip.offsetHeight;

			var origin = (0, _dom.getOffset)(this.origin);

			var top = void 0;
			var left = void 0;

			switch (getEdge(placement)) {
				case 'top':
					top = origin.top - height;
					break;
				case 'bottom':
					top = origin.top + origin.height;
					break;
				case 'left':
					left = origin.left - width;
					break;
				case 'right':
					left = origin.left + origin.width;
					break;
			}

			switch (getEdge(placement)) {
				case 'top':
				case 'bottom':
					switch (getSide(placement)) {
						case 'start':
							left = origin.left;
							break;
						case 'end':
							left = origin.left + origin.width - width;
							break;
						// Default: "center".
						default:
							left = origin.left + (origin.width - width) / 2;
							break;
					}
					break;
				case 'left':
				case 'right':
					switch (getSide(placement)) {
						case 'start':
							top = origin.top;
							break;
						case 'end':
							top = origin.top + origin.height - height;
							break;
						// Default: "center".
						default:
							top = origin.top + (origin.height - height) / 2;
							break;
					}
					break;
			}

			return fitOnScreen(left, top + offsetTop - (0, _dom.getOffset)(this.container()).top, width, height, screenMargin);
		}
	}, {
		key: 'scheduleHide',
		value: function scheduleHide() {
			var _props3 = this.props,
			    hideTimeout = _props3.hideTimeout,
			    hideDelay = _props3.hideDelay;
			// `window.rruiCollapseOnFocusOut` can be used
			// for debugging expandable contents.

			if (window.rruiCollapseOnFocusOut !== false) {
				this.hide_on_mouse_leave_timeout = (0, _requestAnimationFrameTimeout.setTimeout)(this.hide, hideTimeout || hideDelay);
			}
		}
	}, {
		key: 'cancelHide',
		value: function cancelHide() {
			(0, _requestAnimationFrameTimeout.clearTimeout)(this.hide_on_mouse_leave_timeout);
			this.hide_on_mouse_leave_timeout = undefined;
		}
	}, {
		key: '_onMouseEnter',
		value: function _onMouseEnter() {
			var _this2 = this;

			// mouse enter and mouse leave events
			// are triggered on mobile devices too
			if (this.isTouchDevice) {
				return;
			}

			this.isPointerInsideElement = true;

			if (this.isShown) {
				return this.cancelHide();
			}

			var content = this.renderContent();

			// If the tooltip has no content
			// (e.g. `react-time-ago` first render)
			// or if React Portal API is not available
			// then don't show the tooltip.
			if (!content || !_reactDom2.default.createPortal) {
				return;
			}

			// Shouldn't happen, because
			// `mouse leave` event clears this timeout.
			if (this.show_timeout) {
				return;
			}

			// If the tooltip hiding animation is currently playing,
			// then cancel it and re-show the tooltip.
			if (this.hide_timeout) {
				return this.show();
			}

			var delay = this.props.delay;

			// Don't show the tooltip immediately
			// but rather wait for the user to
			// "mouse over" it for a short time interval.
			// (prevents false positives)

			this.show_timeout = (0, _requestAnimationFrameTimeout.setTimeout)(function () {
				_this2.show_timeout = undefined;
				_this2.show();
			}, delay);
		}

		// Is used on the tooltip itself in "accessible" mode.


		// This handler is used both on tooltip toggle button
		// and the tooltip itself.

	}, {
		key: 'renderContent',
		value: function renderContent() {
			var _props4 = this.props,
			    content = _props4.content,
			    Component = _props4.component,
			    componentProps = _props4.componentProps;

			if (content) {
				return content;
			}
			if (Component) {
				return _react2.default.createElement(Component, _extends({}, componentProps, {
					hide: this.hide }));
			}
			return null;
		}
	}, {
		key: 'render',
		value: function render() {
			// Shows tooltip on mouse over when on desktop.
			// Shows tooltip on touch when on mobile.

			// `ReactDOM.createPortal()` requires React >= 16.
			// If it's not available then it won't show the tooltip.

			var content = this.renderContent();

			var tooltip = this.tooltip && content && _reactDom2.default.createPortal && _reactDom2.default.createPortal(content, this.tooltip);

			// For React >= 16.2.
			// Disable React portal event bubbling.
			// https://github.com/facebook/react/issues/11387#issuecomment-340019419
			if (_react2.default.Fragment) {
				return _react2.default.createElement(
					_react2.default.Fragment,
					null,
					this._render(),
					tooltip
				);
			} else {
				// Legacy version support.
				// Can be a bit buggy in some rare cases of mouseentering and mouseleaving.
				// Will be removed in some future major version release.
				return this._render(tooltip);
			}
		}
	}, {
		key: '_render',
		value: function _render(extraChildren) {
			var _props5 = this.props,
			    accessible = _props5.accessible,
			    inline = _props5.inline,
			    style = _props5.style,
			    className = _props5.className,
			    children = _props5.children,
			    placement = _props5.placement,
			    content = _props5.content,
			    container = _props5.container,
			    component = _props5.component,
			    componentProps = _props5.componentProps,
			    delay = _props5.delay,
			    hideDelay = _props5.hideDelay,
			    hideTimeout = _props5.hideTimeout,
			    hidingAnimationDuration = _props5.hidingAnimationDuration,
			    screenMargin = _props5.screenMargin,
			    offsetTop = _props5.offsetTop,
			    tooltipClassName = _props5.tooltipClassName,
			    rest = _objectWithoutProperties(_props5, ['accessible', 'inline', 'style', 'className', 'children', 'placement', 'content', 'container', 'component', 'componentProps', 'delay', 'hideDelay', 'hideTimeout', 'hidingAnimationDuration', 'screenMargin', 'offsetTop', 'tooltipClassName']);

			var isShown = this.state.isShown;


			var Component = accessible ? 'button' : 'div';

			// There's no WAI-ARIA example of an `aria-role="tooltip"` widget.
			// https://www.w3.org/TR/wai-aria-practices-1.1/#tooltip
			//
			// `aria-haspopup`:
			// https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup
			// WAI-ARIA 1.1 is not yet supported, so not using `aria-haspopup="..."`.

			return _react2.default.createElement(
				Component,
				_extends({}, rest, {
					ref: this.storeOriginNode,
					onMouseEnter: this.onMouseEnter,
					onMouseLeave: this.onMouseLeave,
					onClick: accessible ? this.onClick : undefined,
					onTouchStart: accessible ? this.onTouchStartSetTouchDevice : this.onTouchStart,
					onTouchEnd: accessible ? undefined : this.onTouchEnd,
					onTouchMove: accessible ? undefined : this.hide,
					onTouchCancel: accessible ? undefined : this.hide,
					'aria-expanded': accessible ? isShown : undefined,
					type: accessible ? 'button' : undefined,
					style: style,
					className: (0, _classnames2.default)(className, 'rrui__tooltip__target', {
						'rrui__button-reset': accessible,
						'rrui__tooltip__target--inline': inline
					}) }),
				children,
				extraChildren
			);
		}
	}]);

	return Tooltip;
}(PureComponent), _class.propTypes = {
	// Tooltip placement.
	placement: _propTypes2.default.oneOf(['top', 'top-start', 'top-end', 'left', 'left-start', 'left-end', 'bottom', 'bottom-start', 'bottom-end', 'right', 'right-start', 'right-end']).isRequired,

	// Tooltip content.
	content: _propTypes2.default.node,

	// Tooltip content component.
	// Will have access to `hide()` property.
	component: _propTypes2.default.func,
	componentProps: _propTypes2.default.object,

	// Whether this element should be displayed as `inline-block`.
	// (is `true` by default)
	inline: _propTypes2.default.bool.isRequired,

	// If `true` then the tooltip will be accessible via keyboard.
	// The tooltipped element will be wrapped in a focusable `<button/>`
	// that will show/hide the tooltip on click.
	// Tooltip contents will be focused upon being shown.
	// The tooltip will be closeable via `Esc` key.
	// The tooltip will still be shown/hidden on mouseover.
	// (is `false` by default)
	accessible: _propTypes2.default.bool,

	// The delay before the tooltip is shown (in milliseconds)
	delay: _propTypes2.default.number.isRequired,

	// The duration of the tooltip hiding animation.
	// The DOM element will retain `display: block` for this time period.
	// When changing this timeout also change `transition` time for
	// `.tooltip--after-show` and `.tooltip--before-hide` CSS classes.
	// Is `120` by default.
	hidingAnimationDuration: _propTypes2.default.number.isRequired,

	// (`hideTimeout` is deprecated, use `hideDelay` instead)
	// The tooltip waits `hideTimeout` milliseconds before hiding
	// to support mouseovering over itself.
	hideTimeout: _propTypes2.default.number,

	// The tooltip waits `hideDelay` milliseconds before hiding
	// to support mouseovering over itself.
	hideDelay: _propTypes2.default.number.isRequired,

	screenMargin: _propTypes2.default.number.isRequired,
	// When passing `offsetTop`, also set `--rrui-tooltip-visible-distance` to `0px`.
	offsetTop: _propTypes2.default.number.isRequired,

	// `container: () => DOMElement` property is optional
	// and is gonna be the parent DOM Element for the tooltip itself
	// (`document.body` by default).
	// (in which case make sure that `document.body` has no `margin`
	//  otherwise tooltip `left` and `top` positions will be slightly off).
	container: _propTypes2.default.func,

	// CSS style object
	style: _propTypes2.default.object,

	// CSS class name
	className: _propTypes2.default.string,

	// Tooltip CSS class name
	tooltipClassName: _propTypes2.default.string
}, _class.defaultProps = {
	placement: 'top',
	inline: true,
	delay: 350, // in milliseconds
	hidingAnimationDuration: 200, // in milliseconds
	hideDelay: 50, // in milliseconds
	screenMargin: 4, // in pixels
	offsetTop: 0, // in pixels
	container: function container() {
		return document.body;
	}
}, _temp2);
exports.default = Tooltip;


function fitOnScreen(x, y, width, height, minimal_margin) {
	if (x < minimal_margin) {
		x = minimal_margin;
	} else if (x + width + minimal_margin > window.innerWidth) {
		x -= x + width + minimal_margin - window.innerWidth;
	}

	if (y < window.pageYOffset + minimal_margin) {
		y = window.pageYOffset + minimal_margin;
	} else if (y + height + minimal_margin > window.pageYOffset + window.innerHeight) {
		y -= y + height + minimal_margin - (window.pageYOffset + window.innerHeight);
	}

	return { x: x, y: y };
}

/**
 * @param  {string} placement
 * @return {string} One of: "top", "right", "bottom", "left".
 */
function getEdge(placement) {
	var dashIndex = placement.indexOf('-');
	if (dashIndex >= 0) {
		return placement.slice(0, dashIndex);
	}
	return placement;
}

/**
 * @param  {string} placement
 * @return {string} One of: "start", "center", "end".
 */
function getSide(placement) {
	var dashIndex = placement.indexOf('-');
	if (dashIndex >= 0) {
		return placement.slice(dashIndex + '-'.length);
	}
	return 'center';
}

var DocumentMouseMove = {
	wasMouseMoved: false
};

function onDocumentMouseMove() {
	DocumentMouseMove.wasMouseMoved = true;
}

function onDocumentScroll() {
	DocumentMouseMove.wasMouseMoved = false;
}

// There could be several thousand minimized post link quotes on a page
// (when not using `<VirtualScroller/>`). So, in order not to add
// several thousand `mousemove` and `scroll` listeners,
// a single one for each of these two events is added instead.
if (typeof document !== 'undefined') {
	document.addEventListener('mousemove', onDocumentMouseMove);
	document.addEventListener('scroll', onDocumentScroll);
}
//# sourceMappingURL=Tooltip.js.map