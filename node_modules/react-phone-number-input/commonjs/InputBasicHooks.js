'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

exports.createInput = createInput;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _core = require('libphonenumber-js/core');

var _inputValuePrefix = require('./inputValuePrefix');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; } // This is just a rewrite of `./InputSmart.js` using Hooks.
// `./InputSmart.js` wasn't rewritten in Hooks directly
// due to the legacy compatibility with older React versions.
//
// Plus the added support for `international` property.

function createInput(defaultMetadata) {
	/**
  * `InputBasic`'s caret is not as "smart" as the default `inputComponent`'s
  * but still works good enough. When erasing or inserting digits in the middle
  * of a phone number the caret usually jumps to the end: this is the expected
  * behaviour and it's the workaround for the [Samsung Galaxy smart caret positioning bug](https://github.com/catamphetamine/react-phone-number-input/issues/75).
  */
	function InputBasic(_ref, ref) {
		var value = _ref.value,
		    onChange = _ref.onChange,
		    country = _ref.country,
		    international = _ref.international,
		    metadata = _ref.metadata,
		    Input = _ref.inputComponent,
		    rest = _objectWithoutProperties(_ref, ['value', 'onChange', 'country', 'international', 'metadata', 'inputComponent']);

		var prefix = (0, _inputValuePrefix.getInputValuePrefix)(country, international, metadata);

		var _onChange = (0, _react.useCallback)(function (event) {
			var newValue = (0, _core.parseIncompletePhoneNumber)(event.target.value);
			// By default, if a value is something like `"(123)"`
			// then Backspace would only erase the rightmost brace
			// becoming something like `"(123"`
			// which would give the same `"123"` value
			// which would then be formatted back to `"(123)"`
			// and so a user wouldn't be able to erase the phone number.
			// Working around this issue with this simple hack.
			if (newValue === value) {
				var newValueFormatted = format(prefix, newValue, country, metadata);
				if (newValueFormatted.indexOf(event.target.value) === 0) {
					// Trim the last digit (or plus sign).
					newValue = newValue.slice(0, -1);
				}
			}
			onChange(newValue);
		}, [prefix, value, onChange, country, metadata]);

		return _react2.default.createElement(Input, _extends({}, rest, {
			ref: ref,
			value: format(prefix, value, country, metadata),
			onChange: _onChange }));
	}

	InputBasic = _react2.default.forwardRef(InputBasic);

	InputBasic.propTypes = {
		/**
   * The parsed phone number.
   * "Parsed" not in a sense of "E.164"
   * but rather in a sense of "having only
   * digits and possibly a leading plus character".
   * Examples: `""`, `"+"`, `"+123"`, `"123"`.
   */
		value: _propTypes2.default.string.isRequired,

		/**
   * Updates the `value`.
   */
		onChange: _propTypes2.default.func.isRequired,

		/**
   * A two-letter country code for formatting `value`
   * as a national phone number (e.g. `(800) 555 35 35`).
   * E.g. "US", "RU", etc.
   * If no `country` is passed then `value`
   * is formatted as an international phone number.
   * (e.g. `+7 800 555 35 35`)
   * Perhaps the `country` property should have been called `defaultCountry`
   * because if `value` is an international number then `country` is ignored.
   */
		country: _propTypes2.default.string,

		/**
   * If `country` property is passed along with `international={true}` property
   * then the phone number will be input in "international" format for that `country`
   * (without "country calling code").
   * For example, if `country="US"` property is passed to "without country select" input
   * then the phone number will be input in the "national" format for `US` (`(213) 373-4253`).
   * But if both `country="US"` and `international={true}` properties are passed then
   * the phone number will be input in the "international" format for `US` (`213 373 4253`)
   * (without "country calling code" `+1`).
   */
		international: _propTypes2.default.bool,

		/**
   * `libphonenumber-js` metadata.
   */
		metadata: _propTypes2.default.object.isRequired,

		/**
   * The `<input/>` component.
   */
		inputComponent: _propTypes2.default.elementType.isRequired
	};

	InputBasic.defaultProps = {
		metadata: defaultMetadata,
		inputComponent: 'input'
	};

	return InputBasic;
}

exports.default = createInput();


function format(prefix, value, country, metadata) {
	return (0, _inputValuePrefix.removeInputValuePrefix)((0, _core.formatIncompletePhoneNumber)(prefix + value, country, metadata), prefix);
}
//# sourceMappingURL=InputBasicHooks.js.map